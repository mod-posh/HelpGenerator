# ADR-007 â€” MAML Generation Contract

**Status:** Accepted
**Date:** 2026-02-20

---

## Context

The Help Generator suite produces **external help (MAML)** files for:

* Script-based modules
* Compiled C# cmdlets

PowerShell external help must conform to the MAML schema used by PowerShell help engines. Even when schema validation passes, structural inconsistencies (ordering, missing sections, unexpected nesting) can cause rendering issues or future incompatibility.

To ensure:

* Deterministic output
* Schema validity
* PowerShell compatibility
* Testable golden fixtures

We define a strict MAML generation contract.

---

## Decision

All MAML generated by this suite must:

1. Follow a deterministic node ordering.
2. Render all supported sections in a consistent structure.
3. Be generated solely from the NormalizedHelpModel.
4. Avoid runtime-specific formatting logic.
5. Be stable across runs for identical inputs.

---

## 1. File-Level Structure

Each culture produces one MAML file:

```bash
<ModuleName>-Help.xml
```

Root structure:

```xml
<helpItems xmlns="http://msh">
  <command>
    ...
  </command>
  <command>
    ...
  </command>
</helpItems>
```

Rules:

* One `<command>` per exported command.
* Commands are sorted alphabetically by command name.
* No runtime-dependent ordering.

---

## 2. Command Node Contract

Each `<command>` node must contain the following sections in this exact order:

1. `<details>`
2. `<description>`
3. `<syntax>`
4. `<parameters>`
5. `<inputTypes>` (if applicable)
6. `<returnValues>` (if applicable)
7. `<examples>` (if present)
8. `<relatedLinks>` (if present)

Sections may be omitted only if no data exists, except:

* `<details>` is required.
* `<syntax>` is required.
* `<parameters>` must exist (even if empty).

---

## 3. `<details>` Section

Required structure:

```xml
<details>
  <name>Get-Example</name>
  <verb>Get</verb>
  <noun>Example</noun>
  <description>
    <para>Short synopsis text.</para>
  </description>
</details>
```

Rules:

* `<name>` must match exported command name exactly.
* Verb and noun must match `[Cmdlet]` or parsed function name.
* Synopsis is single-paragraph content from normalized model.

---

## 4. `<description>` Section

```xml
<description>
  <para>Full description paragraph 1.</para>
  <para>Paragraph 2.</para>
</description>
```

Rules:

* Derived from `<remarks>` (compiled) or `.DESCRIPTION` (script).
* Multiple paragraphs rendered as multiple `<para>` nodes.
* No raw markdown inside `<para>` nodes.
* No HTML.

---

## 5. `<syntax>` Section

Each parameter set produces one `<syntaxItem>`.

```xml
<syntax>
  <syntaxItem>
    <name>Get-Example</name>
    <parameter>
      <name>Id</name>
      <parameterValue required="true">String</parameterValue>
    </parameter>
  </syntaxItem>
</syntax>
```

Rules:

* Parameter sets are sorted alphabetically.
* Parameters within each set are sorted by:

  1. Position (if defined)
  2. Alphabetically
* Switch parameters omit `<parameterValue>` type text if appropriate.
* Pipeline support is expressed via attributes when supported.
* Mandatory attribute reflected as `required="true"`.

---

## 6. `<parameters>` Section

Each parameter rendered once, independent of parameter sets:

```xml
<parameters>
  <parameter>
    <name>Id</name>
    <description>
      <para>Specifies the identifier.</para>
    </description>
    <parameterValue required="true">String</parameterValue>
  </parameter>
</parameters>
```

Rules:

* Description derived from XML doc `<param>` or script help `.PARAMETER`.
* If no description exists, placeholder text is inserted.
* Aliases included where applicable.
* Default values may be rendered if available.

---

## 7. `<inputTypes>` Section

Rendered only if explicitly defined.

```xml
<inputTypes>
  <inputType>
    <type>
      <name>System.String</name>
    </type>
  </inputType>
</inputTypes>
```

Rules:

* Derived from reflection or script metadata.
* If none defined, section omitted.

---

## 8. `<returnValues>` Section

```xml
<returnValues>
  <returnValue>
    <type>
      <name>System.String</name>
    </type>
    <description>
      <para>Returns a string.</para>
    </description>
  </returnValue>
</returnValues>
```

Rules:

* Derived from `[OutputType]` or XML `<returns>`.
* Omitted if not available.

---

## 9. `<examples>` Section

```xml
<examples>
  <example>
    <title>Example 1</title>
    <code>Get-Example -Id 1</code>
    <remarks>
      <para>Retrieves example with ID 1.</para>
    </remarks>
  </example>
</examples>
```

Rules:

* Ordered as defined in source.
* Title auto-generated if absent.
* Code blocks preserved exactly as authored.
* Multiple examples supported.
* No formatting inference.

---

## 10. `<relatedLinks>` Section

Rendered if links are defined.

```xml
<relatedLinks>
  <navigationLink>
    <linkText>About Examples</linkText>
    <uri>https://example.com</uri>
  </navigationLink>
</relatedLinks>
```

---

## 11. Determinism Requirements

The following must be deterministic:

* Command ordering
* Parameter ordering
* Parameter set ordering
* XML indentation
* Attribute ordering
* Namespace declaration placement

Golden fixture tests must be able to perform exact file comparisons.

---

## 12. Culture Handling

* One MAML file per culture.
* Default culture: `en-US`.
* If additional cultures are supported, each must produce separate file trees.
* Culture is controlled by HelpInfo.xml and generation options.

---

## 13. Validation Rules

The suite must provide:

* Schema validation (where feasible)
* Semantic validation:

  * Missing synopsis
  * Missing parameter descriptions
  * Duplicate parameter names
  * Invalid verb-noun combinations
  * Missing examples (warning level)

Validation does not auto-fix content.

---

## 14. Guardrails

We do not:

* Generate synthetic prose
* Infer examples automatically
* Inject markdown formatting
* Reorder content based on heuristics
* Deviate from PowerShell help expectations

The generator is structural and deterministic, not creative.

---

## Rationale

Defining a strict MAML contract:

* Prevents format drift
* Enables stable CI validation
* Ensures PowerShell compatibility
* Simplifies test design
* Allows side-by-side diffing in releases

---

## Consequences

Positive:

* Predictable help artifacts
* Easy regression detection
* Clear separation between parsing and rendering

Trade-offs:

* Requires disciplined input
* Strict structure may require iterative refinement during early development
