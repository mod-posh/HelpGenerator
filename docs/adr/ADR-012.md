# ADR-012 — Comment-Based Help AST Parsing Contract

**Status:** Accepted
**Date:** 2026-02-20

---

## Context

To generate help consistently from script-based PowerShell, the suite must:

* Discover exported functions in `.ps1` and `.psm1`
* Detect and parse comment-based help blocks
* Correctly associate help blocks with their target function
* Scaffold placeholders deterministically when help is missing
* Avoid fragile regex-only parsing

PowerShell scripts can include:

* Multiple functions
* Nested functions
* Regions
* Dot-sourced includes
* Multiple comment blocks near a function

This ADR defines the contract for discovery, association, parsing, and scaffolding.

---

## Decision

### 1. Discovery uses PowerShell AST

We use PowerShell’s parser to build an AST and identify:

* `FunctionDefinitionAst` nodes
* Advanced functions (presence of `CmdletBinding`)
* Function name and declared parameters
* Parameter attributes (e.g., `Parameter`, `Alias`, validations)

We do not rely on regex for function discovery.

---

### 2. Which functions are “documented targets”

In `.ps1` (single script file):

* All top-level functions are considered targets unless excluded by configuration.

In `.psm1` (module script):

* All top-level functions are targets by default.
* If a manifest `.psd1` is provided and includes `FunctionsToExport`, we treat that as the authoritative export list.
* If the module uses `Export-ModuleMember`, we will optionally honor it (future improvement), but initial contract assumes `.psd1` is the preferred export authority.

Exclusions:

* Functions may be excluded via:

  * `-ExcludeFunction <pattern[]>` option, or
  * a recognized marker in help (e.g., `.EXTERNALHELPGENERATORIGNORE`) (future; not required).

---

### 3. Help block association rules (deterministic)

For a function `F`, the associated comment-based help block is determined by:

**Primary association rule:**

* The closest comment-based help block **immediately preceding** the function definition, with only whitespace and/or attribute lines between it and the function definition.

Accepted separation between help block and function:

* Blank lines
* Attribute blocks applied to the function (e.g., `[CmdletBinding()]`, `[OutputType()]`)

Not accepted separation:

* Any executable statement
* Another function definition
* Another comment-based help block closer to the function

If multiple candidate help blocks exist:

* Choose the nearest valid help block.
* Emit a warning if ambiguity is detected (e.g., two help blocks within N lines).

---

### 4. Supported comment-based help formats

We support:

**Block help:**

```powershell
<#
.SYNOPSIS
...
#>
function Get-Thing { }
```

**Line help:**

```powershell
function Get-Thing {
  # .SYNOPSIS
  # ...
}
```

Initial v1 contract prioritizes block help (`<# #>`). Line help support is allowed but may be limited to well-formed patterns.

---

### 5. Parsing contract (tokenization, not prose rewriting)

We parse standard help directives:

* `.SYNOPSIS`
* `.DESCRIPTION`
* `.PARAMETER <Name>`
* `.EXAMPLE`
* `.INPUTS`
* `.OUTPUTS`
* `.NOTES`
* `.LINK`
* `.COMPONENT`, `.ROLE`, `.FUNCTIONALITY` (captured as notes/metadata if present)

Rules:

* Preserve paragraph breaks.
* Preserve example code exactly.
* Preserve ordering of examples.
* Do not auto-correct spelling, punctuation, or casing.
* Treat unknown directives as Notes (warning level).

---

### 6. Parameter reconciliation rules

After parsing help content, we reconcile parameter help with actual function parameters from AST:

Errors:

* Help documents a parameter that does not exist in function signature (configurable strict mode)
  Warnings:
* Function has a parameter that is undocumented in help
* Help describes parameter but signature differs (type/position mismatch if discoverable)

We always generate a complete `CommandHelp.Parameters` model:

* Missing prose becomes placeholder text (per ADR-009).

---

### 7. Scaffolding contract (when help is missing)

If no help block is associated with a function, we generate a deterministic scaffold.

For scripts:

* Default behavior: create a new help block inserted immediately above the function definition.

Scaffold structure:

```powershell
<#
.SYNOPSIS
TODO: Add synopsis.

.DESCRIPTION
TODO: Add description.

.PARAMETER Name
TODO: Describe -Name.

.EXAMPLE
TODO: Add example.

.NOTES
TODO: Add notes.
#>
```

Rules:

* Include `.PARAMETER` sections for every parameter in signature.
* Include at least one `.EXAMPLE`.
* Do not include `.INPUTS`/`.OUTPUTS` unless discoverable.
* Preserve original formatting and indentation as much as possible.
* No rewriting of existing code beyond insertion of help block.

If configured “no in-place edits” mode:

* Emit scaffold blocks as sidecar files in `/scaffolds/<CommandName>.help.txt`.

---

### 8. Guardrails

We do not:

* Execute PowerShell code
* Resolve dot-sourced includes automatically (future enhancement)
* Infer intent from code behavior
* Generate prose beyond placeholders

---

## Consequences

Positive:

* Correct and repeatable help association
* Robust against code formatting differences
* Clear behavior for missing/ambiguous help blocks

Trade-offs:

* Dot-sourcing/module composition isn’t fully resolved in v1 without explicit inputs
* Some edge cases may require explicit configuration (e.g., export lists)
