# ADR-006 — Compiled C# Cmdlets Help Pipeline

**Status:** Accepted
**Date:** 2026-02-20

---

## Context

The Help Generator suite must support both:

* Script-based PowerShell functions/modules (comment-based help)
* Compiled C# cmdlets (binary modules)

Because this project generates MAML, HelpInfo.xml, and Markdown documentation, it must support compiled cmdlets as first-class citizens — including cmdlets written as part of this project.

We explicitly do **not** leverage or extend PlatyPS. The suite must own the compiled cmdlet help pipeline end-to-end.

---

## Decision

### 1. Compiled cmdlets are supported as primary inputs

Supported input types for compiled modules:

* PowerShell module assembly (`.dll`)
* XML documentation file emitted during build (`.xml`)
* Optional future: structured help sidecar file (if defined by this project)

The build for compiled cmdlets **must enable XML documentation generation**:

```xml
<PropertyGroup>
  <GenerateDocumentationFile>true</GenerateDocumentationFile>
</PropertyGroup>
```

The XML documentation file is required to provide human-authored help content.

---

### 2. Metadata discovery via reflection

The suite will use reflection to discover cmdlet structure:

* `[Cmdlet(Verb, Noun)]`
* `[Parameter]`
* Parameter sets
* Parameter types
* Mandatory flags
* Pipeline binding attributes
* Output types (via `[OutputType]`)
* Aliases (via `[Alias]`)
* Cmdlet class inheritance (Cmdlet vs PSCmdlet)

Reflection provides **structural metadata only**.

Reflection does **not** provide authoritative help prose.

---

### 3. Human-authored content source

Human-authored documentation content must originate from one of:

1. XML documentation file (preferred)
2. A structured sidecar help file (future extension if needed)

The following XML doc elements are used:

| XML Element                     | Mapped To             |
| ------------------------------- | --------------------- |
| `<summary>`                     | Synopsis              |
| `<remarks>`                     | Description           |
| `<param name="">`               | Parameter description |
| `<returns>`                     | Output description    |
| `<example>` (custom convention) | Examples              |
| `<para>`                        | Paragraph formatting  |

If `<example>` is not part of the official XML schema, we support it as a convention within `<remarks>` or as a structured extension.

If XML documentation is missing:

* The suite will generate placeholder help scaffolds.
* Validation will warn that prose is missing.

---

### 4. Normalized model integration

Compiled cmdlets are transformed into the same **normalized help model** used for script-based help.

Pipeline:

```bash
Assembly + XML docs
        ↓
Reflection + XML parsing
        ↓
NormalizedHelpModel
        ↓
MAML Generator
Markdown Generator
HelpInfo.xml Generator
```

All output generators operate identically regardless of source type.

This guarantees:

* Consistent output format
* Testable golden fixtures
* Stable markdown contracts
* Identical MAML shape for script and compiled modules

---

### 5. Generated artifacts

For compiled modules, the suite generates:

* External help MAML (`<ModuleName>-Help.xml`)
* HelpInfo.xml
* Discrete Markdown documentation
* Optional updatable help folder structure

Artifact layout remains governed by ADR-004.

---

## Guardrails

1. Reflection is metadata-only.

   * It defines structure.
   * It does not define prose quality.

2. XML documentation (or future structured help sidecar) is the authoritative prose source.

3. We do not attempt to infer meaningful descriptions from:

   * Parameter names
   * Types
   * Attribute metadata alone

4. We do not auto-generate “AI-written” prose.

If human-written documentation is absent, we generate placeholders.

---

## Rationale

Supporting compiled cmdlets:

* Enables first-class documentation for binary modules.
* Allows this project to dogfood itself.
* Supports broader adoption beyond script-only modules.
* Preserves deterministic output independent of PlatyPS.

Using XML documentation files:

* Integrates cleanly with standard .NET build workflows.
* Encourages maintainable, version-controlled help content.
* Keeps prose close to source code.

Using a normalized model:

* Avoids dual logic paths.
* Simplifies testing.
* Ensures future extensibility without rewriting generators.

---

## Consequences

Positive:

* Full parity between script and compiled cmdlet support.
* Deterministic documentation generation.
* Clean separation of structure (reflection) and prose (XML docs).

Trade-offs:

* XML documentation becomes mandatory for quality output.
* Developers must follow documentation discipline during build.

---

## Future Considerations (Not Committed)

* Structured `<example>` XML extension schema
* Custom attributes for richer help metadata
* Roslyn-based source parsing for deeper analysis
* Validation rule set for missing or incomplete XML documentation

These are explicitly optional and must remain within help-generation scope.
